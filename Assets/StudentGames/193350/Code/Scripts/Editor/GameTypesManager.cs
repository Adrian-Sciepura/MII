using UnityEditor;
using UnityEngine;
using System.Text;
using System.IO;
using System.Collections.Generic;
using System;
using System.Linq;

public class GameTypesManager : AssetModificationProcessor
{
    private static readonly string SO_PATH = "Assets/Resources/193350";
    private static string OUTPUT_PATH => Path.Combine(Application.dataPath, "StudentGames/193350/Code/Scripts/AutoGenerated-DO_NOT_TOUCH");

    public static string[] OnWillSaveAssets(string[] paths)
    {
        (string path, bool found)[] search = 
        {
            ( "Assets/Resources/193350/Item", false )
        };

        foreach (string path in paths)
        {
            for(int i = 0; i < search.Length; i++)
            {
                var s = search[i];
                if(!s.found && path.StartsWith(s.path))
                    search[i].found = true;
            }
        }


        if (search[0].found)
            RegenerateFile<ItemPrefabSO>("/Item", "ItemType");

        if (search.Any(x => x.found))
            AssetDatabase.Refresh();

        return paths;
    }



    private static void RegenerateFile<SOType>(string subCatalog, string generatedTypeName) where SOType : ScriptableObject, IAutoGenerated
    {
        string[] assets = AssetDatabase.FindAssets("t:" + typeof(SOType).Name, new[] { SO_PATH + subCatalog });

        Dictionary<string, int> typeValues = new Dictionary<string, int>();
        StringBuilder outputFileBuilder = new StringBuilder();

        int i = 0;
        foreach (var asset in assets)
        {
            SOType SOAsset = AssetDatabase.LoadAssetAtPath<SOType>(AssetDatabase.GUIDToAssetPath(asset));
            string name = SOAsset.GetGeneratedName();

            if (SOAsset.Validate() && !typeValues.ContainsKey(name))
                typeValues.Add(name, i++);
        }

        Type existingType = Type.GetType($"{generatedTypeName}, Assembly-CSharp");

        if (existingType != null)
        {
            foreach (var member in Enum.GetValues(existingType))
            {
                int memberAsInt = (int)member;
                string memberAsString = member.ToString();

                if (!typeValues.ContainsKey(memberAsString))
                    continue;

                int currentValue = typeValues[memberAsString];

                if (currentValue != memberAsInt)
                {
                    var result = typeValues.FirstOrDefault(x => x.Value == memberAsInt);
                    typeValues[memberAsString] = memberAsInt;

                    if (result.Equals(default(KeyValuePair<int, string>)))
                        continue;

                    typeValues[result.Key] = currentValue;
                }
            }
        }


        outputFileBuilder.AppendLine($"public enum {generatedTypeName}");
        outputFileBuilder.AppendLine("{");

        var types = typeValues.OrderBy(x => x.Key).ToList();
        foreach (var (type, id) in types)
            outputFileBuilder.AppendLine($"\t{type} = {id},");

        outputFileBuilder.AppendLine("}");

        using (StreamWriter streamWriter = new StreamWriter(Path.Combine(OUTPUT_PATH, $"{generatedTypeName}.cs")))
            streamWriter.Write(outputFileBuilder);
    }
}